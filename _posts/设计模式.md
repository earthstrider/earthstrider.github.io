### 代理模式

**模式动机**

在某些情况下，一个客户不想或者不能直接引用一个对 象，此时可以通过一个称之为“代理”的第三者来实现 间接引用。代理对象可以在客户端和目标对象之间起到 中介的作用，并且可以通过代理对象去掉客户不能看到 的内容和服务或者添加客户需要的额外服务。



**模式定义**

代理模式(Proxy Pattern) ：给某一个对象提供一个代 理，并由代理对象控制对原对象的引用。代理模式的英 文叫做Proxy或Surrogate，它是一种对象结构型模式。



**模式结构**

- Subject: 抽象主题角色
- Proxy: 代理主题角色
- RealSubject: 真实主题角色

![../_images/Proxy.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/Proxy.jpg)



**时序图**

![../_images/seq_Proxy.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/seq_Proxy.jpg)



**代码实现**

```java
abstract class BuyCar{
    abstract void buy();
}

class BuyCarProxy extends BuyCar{
    private BuyCarReal buyCarReal;

    BuyCarProxy(){
        buyCarReal = new BuyCarReal();
    }

    @Override
    void buy() {
        preBuy();
        buyCarReal.buy();
        afterBuy();
    }

    void preBuy(){
        System.out.println("pre buy");
    }

    void afterBuy(){
        System.out.println("after buy");
    }
}

class BuyCarReal extends BuyCar{

    @Override
    void buy() {
        System.out.println("buy");
    }
}


class Client{
    public static void main(String[] args) {
        BuyCarProxy buyCarProxy = new BuyCarProxy();
        buyCarProxy.buy();
    }
}
```

运行结果如下：
![image-20190902103648012](https://tva1.sinaimg.cn/large/006y8mN6ly1g6kz04i71uj30v2068q3e.jpg)





### 适配器模式

**模式定义**

适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。



**模式结构**

- Target：目标抽象类
- Adapter：适配器类
    - Adaptee：适配者类
- Client：客户类



对象适配器（关联适配者）

![../_images/Adapter.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/Adapter.jpg)

类适配器（继承适配者）

![../_images/Adapter_classModel.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/Adapter_classModel.jpg)

类适配器的重点在于类，是通过继承Adaptee类构造适配器；对象适配器的重点在于对象，是通过直接关联Adaptee类来构造适配器，当需要调用特殊功能的时候直接使用Adapter中的Adaptee对象来调用特殊功能的方法即可。



**代码实现**

对象适配器

```java
// 目标者
interface MediaTarget {
    public void play();
}

// 适配者，被适配的接口
interface MediaAdaptee {
    void playFile();
}

// 对象适配器，用来适配MediaAdaptee类的对象
class FormatObjectAdapter implements MediaTarget {
    private MediaAdaptee media;

    FormatObjectAdapter(MediaAdaptee _media) {
        this.media = _media;
    }

    @Override
    public void play() {
        System.out.print("Using Object Adapter - ");
        media.playFile();
    }
}

// 类适配器，用来适配Mp4类
class Mp4ClassAdapter extends Mp4 implements MediaTarget{

    @Override
    public void play() {
        System.out.print("Using Class Adapter - ");
        super.playFile();
    }
}

class Mp3 implements MediaTarget {

    @Override
    public void play() {
        System.out.println("Playing MP3 File");
    }

}

class Mp4 implements MediaAdaptee {

    public void playFile() {
        System.out.println("Playing MP4 File");
    }
}

class Vlc implements MediaAdaptee {

    @Override
    public void playFile() {
        System.out.println("Playing VLC File");
    }
}

class Cilent {
    public static void main(String[] args) {
        // test MediaTarget
        MediaTarget player1 = new Mp3();
        player1.play();

        // test FormatObjectAdapter
        MediaTarget player2 = new FormatObjectAdapter(new Mp4());
        player2.play();
        
        MediaTarget player3 = new FormatObjectAdapter(new Vlc());
        player3.play();

        // test FormatClassAdapter
        MediaTarget player4 = new Mp4ClassAdapter();
        player4.play();

    }
}
```





### 命令模式

**模式定义**

命令模式(Command Pattern)：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。



**模式结构**

![../_images/Command.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/Command.jpg)

Invoker和Receiver之间没有直接关系。



**代码实现**

```java
interface Command {
    public void execute();
}

//Concrete Command 开灯
class LightOnCommand implements Command {
    //reference to the light
    LightReceiver light;

    public LightOnCommand(LightReceiver light) {
        this.light = light;
    }

    public void execute() {
        light.switchOn();
    }
}

// 关灯
class LightOffCommand implements Command {
    //reference to the light
    LightReceiver light;

    public LightOffCommand(LightReceiver light) {
        this.light = light;
    }

    public void execute() {
        light.switchOff();
    }
}


//Receiver
class LightReceiver {
    private boolean on;

    public void switchOn() {
        on = true;
    }

    public void switchOff() {
        on = false;
    }
}


//Invoker
class RemoteControlInvoker {
    private Command command;

    public void setCommand(Command command) {
        this.command = command;
    }

    public void pressButton() {
        command.execute();
    }
}


//Client
class Client1 {
    public static void main(String[] args) {
        RemoteControlInvoker control = new RemoteControlInvoker();
        LightReceiver light = new LightReceiver();
        Command lightsOn = new LightOnCommand(light);
        Command lightsOff = new LightOffCommand(light);
        //switch on
        control.setCommand(lightsOn);
        control.pressButton();
        //switch off
        control.setCommand(lightsOff);
        control.pressButton();
    }
}
```

Client中有对RemoteControlInvoker的对象的引用，为什么在类图中Client与Invoker之间没有关联关系？

